# **The Vikings problem**

**Problem analysis and solution**

**tldr**
This implementation uses eulerianWalk algorithm to determine the longest path in a undirected graph.
This report presents the search for the solution to the problem proposed in the discipline of Algorithms and Programming III, in the second half of 2016: determining what is a possible route of Vikings attacks.

**Introduction**

The report is based on the resolution of the problem to determine which is a possible route of Viking attacks, in short: given a set of villages (vertices) and roads (edges) determine which is the largest possible route of attacks.

**Requirements analysis**

The problem presented assumes that all roads have length 1 and the longest route is given by the number of roads that were used. Also, the same vertex (city) can be visited more than once, and an edge (road) cannot. Each edge is composed of two numbers, that is, the two vertices that are connected by it, however, they are not directed, that is, they do not have a single meaning.

Cities are numbered from 0 to n-1 where for this work the maximum number of cities is 25. The maximum degree of a vertex is 3. Finally, the graph is not necessarily connected, that is, not all cities are accessible.

Figure 1 below exemplifies a graph that meets all requirements:

![](https://i.imgur.com/7gea6Ue.png)

_Picture 1 - Graph example provided with the problem_

**Approach**

Initially, the research started with the Dijkstra algorithm, which seeks to find the path with the lowest cost between two points in the graph. The approach was to invert the logic to find the most cost-effective path, however, originally Dijkstra is used in weighted graphs. The premise is that both vertices and edges cannot be revisited, even if we change the weight of all routes to 1, we would not have the guarantee that the longest path would be able to revisit the same city.

In the midst of research on the specific type of graph dealt with in this work, here Eulerian graphs appear as an approximation.

**The Eulerian path**

According to definition, an Euler or Semi-Eulerian graph is a graph where all its edges can be visited sequentially and the vertices can be revisited. An Euler circuit, also called the Eulerian graph, is when it is possible to go through all the edges and return to the same starting vertex.

The algorithms that deal with this problem are usually focused on determining whether a graph is Eulerian or Semi-Eulerian which can be determined through mathematical definitions, so these algorithms alone do not solve the problem.

In our case, as the graphs are not committed to being Eulerian, or Semi-Eulerian, calculating their maximum distance can only be done by exploring all possible combinations (Brute force).

**The algorithm**

The recursive walking (depth) pattern made in Euler's algorithm inspired the development of a modified version that does not keep the vertices as visited, but the edges.

The basic operation of the algorithm starts by defining the size of a list of lists that is used to store all vertices and their connections. These data entries are provided through file reading.

After reading the file and validating its information according to the restrictions defined in the statement of this work, the data is stored in the class _Graph_.

The method _calculateLongestPath()_ Perform a recursive search recording all vertices walked and when finding a dead end path, on recursion return. The longest path found so far including alternative routes is recorded in an attribute of the class and the vertices visited are  &quot;unvisited&quot; so that they can possibly be visited by another path.

To ensure the longest possible path, all possible routes are calculated from all vertices in the graph.

To illustrate the results, an additional class was developed in order to format the output list with all routes in a text format that can be used to generate visual graphs in GraphViz.

Then, for all input graphs, blocks of text in the GraphViz format are generated as many as alternative routes found for the maximum number of vertices walked.

In graphs generated by GraphViz, the initial vertex is identified with yellow, the final vertex with blue and the edges covered with red.

If the initial vertex is the same as the end, it will be identified with the color green.

**Test cases**

All test cases provided by the teacher are within the project, however, the application expects the input path to be passed as an input argument by the terminal.

**Input 0**

**File t0.in**

**Input:**

15 16

0 2

1 2

2 3

3 4

3 5

4 6

5 7

6 8

7 8

7 9

8 10

9 11

10 12

11 12

10 13

12 14

**Size of the longest route found: 12 with 8 alternative routes.**

**Code generated to view the graph in GraphViz:**

_graph G {_

_rankdir = LR;_

_node [shape= circle style=filled fillcolor=&quot;#FFFFFF&quot;];_

_0 -- 2 [color=&quot;red&quot;]_

_1 -- 2_

_2 -- 3 [color=&quot;red&quot;]_

_3 -- 4 [color=&quot;red&quot;]_

_3 -- 5 [color=&quot;red&quot;]_

_4 -- 6 [color=&quot;red&quot;]_

_5 -- 7 [color=&quot;red&quot;]_

_6 -- 8 [color=&quot;red&quot;]_

_7 -- 8_

_7 -- 9 [color=&quot;red&quot;]_

_8 -- 10 [color=&quot;red&quot;]_

_9 -- 11 [color=&quot;red&quot;]_

_10 -- 12 [color=&quot;red&quot;]_

_11 -- 12 [color=&quot;red&quot;]_

_10 -- 13_

_12 -- 14_

_0 [fillcolor=&quot;yellow&quot;]_

_3 [fillcolor=&quot;cyan&quot;]_

_}_

![](https://i.imgur.com/VYsxSSo.png)

_Picture 2 - longest path found by the file t0.in_

**Input 1**

**File t1.in**

**Input:**

20 25

0 2

0 9

10 12

10 13

11 14

1 17

1 19

12 14

15 16

18 14

18 13

19 2

13 14

9 8

2 3

3 16

3 4

3 5

4 6

6 8

7 8

1 19

17 19

8 10

2 11

**Output:**

Exception in thread &quot;main&quot; java.lang.IllegalStateException: List is already at maximum size of 3

The t1.in file violates the constraint that requires the maximum degree of each vertex to be 3. In line 15, 16, 17 and 18 the vertex of number 3 creates edges with vertices 2, 16, 4 and 5 respectively.

**Input 2**

**File t2.in**

**Input:**

20 23

0 2

1 2

2 3

3 4

3 5

4 6

5 7

3 11

7 8

7 4

6 9

8 10

9 11

10 12

7 12

10 13

12 14

5 15

15 16

16 17

16 18

18 19

6 12

**Output:**

Exception in thread &quot;main&quot; java.lang.IllegalStateException: List is already at maximum size of 3

The reason for the Exception of the t2.in file is the same as the reason for the t1.in file. Where the restriction of the maximum value of the degree of the vertices has been violated.

**Input 3**

**File t3.in**

**Input:**

20 24

0 2

1 2

2 3

3 4

3 5

4 6

5 7

3 11

7 8

7 4

6 9

8 10

9 11

10 12

7 12

10 13

12 14

5 15

15 16

16 17

16 18

18 19

6 12

18 1

**Output:**

Exception in thread &quot;main&quot; java.lang.IllegalStateException: List is already at maximum size of 3

The reason for the Exception of the t3.in file is the same as for the t1.in and t2.in files. Where the restriction of the maximum value of the degree of the vertices has been violated.

**Input 4**

**File t4.in**

**Input:**

20 23

0 2

1 2

2 3

3 4

3 5

4 6

3 11

7 8

7 4

6 9

8 10

9 11

10 12

7 12

10 13

12 14

5 15

15 16

16 17

16 18

18 19

6 12

18 1

**Output:**

Exception in thread &quot;main&quot; java.lang.IllegalStateException: List is already at maximum size of 3

The reason for the Exception of the t4.in file is the same as for the t1.in, t2.in and t3.in files. Where the restriction of the maximum value of the degree of the vertices has been violated.

**Input 5**

**File t5.in**

**Input:**

20 22

0 2

1 2

2 3

3 4

3 5

4 6

7 8

7 4

6 9

8 10

9 11

10 12

7 12

10 13

12 14

5 15

15 16

16 17

16 18

18 19

6 12

18 1

**Output:**

Exception in thread &quot;main&quot; java.lang.IllegalStateException: List is already at maximum size of 3

The reason for the Exception of the t5.in file is the same as the t1.in, t2.in, t3.in and t4.in files. Where the restriction of the maximum value of the degree of the vertices has been violated.

**Input 6**
**File t6.in**

**Input:**

20 20

0 2

1 2

2 3

3 5

4 6

7 8

7 4

6 9

8 10

9 11

10 12

7 12

10 13

5 15

15 16

16 17

16 18

18 19

6 12

18 1

**Size of the longest route found: 8 with 22 alternative routes.**

**Code generated to view the graph in GraphViz:**

_graph G {_

_rankdir = LR;_

_node [shape= circle style=filled fillcolor=&quot;#FFFFFF&quot;];_

_0 -- 2 [color=&quot;red&quot;]_

_1 -- 2 [color=&quot;red&quot;]_

_2 -- 3 [color=&quot;red&quot;]_

_3 -- 5 [color=&quot;red&quot;]_

_4 -- 6_

_7 -- 8_

_4 -- 7_

_6 -- 9_

_8 -- 10_

_9 -- 11_

_10 -- 12_

_7 -- 12_

_10 -- 13_

_5 -- 15 [color=&quot;red&quot;]_

_15 -- 16 [color=&quot;red&quot;]_

_16 -- 17_

_16 -- 18 [color=&quot;red&quot;]_

_18 -- 19_

_6 -- 12_

_1 -- 18 [color=&quot;red&quot;]_

_0 [fillcolor=&quot;yellow&quot;]_

_2 [fillcolor=&quot;cyan&quot;]_

_}_

![](https://i.imgur.com/b4vUDtt.png)

_Picture 3 - longest path found by the file t6.in_

**Input 7**

**Input:**

8 10

0 1

0 6

1 2

2 3

3 4

4 5

4 7

5 6

6 7

0 5

**Size of the longest route found: 9 with 48 alternative routes.**

**Code generated to view the graph in GraphViz:**

_graph G{_

_rankdir = LR;_

_node [shape= circle style=filled fillcolor=&quot;#FFFFFF&quot;];_

_0 -- 1 [color=&quot;red&quot;]_

_0 -- 6 [color=&quot;red&quot;]_

_1 -- 2 [color=&quot;red&quot;]_

_2 -- 3 [color=&quot;red&quot;]_

_3 -- 4 [color=&quot;red&quot;]_

_4 -- 5 [color=&quot;red&quot;]_

_4 -- 7 [color=&quot;red&quot;]_

_5 -- 6_

_6 -- 7 [color=&quot;red&quot;]_

_0 -- 5 [color=&quot;red&quot;]_

_0 [fillcolor=&quot;yellow&quot;]_

_4 [fillcolor=&quot;cyan&quot;]_

_}_

**Image showing the longest path found:**

![](https://i.imgur.com/wHzcnuo.png)

_Picture 4 - longest path found by the file t7.in_

**Conclusion**
After a long research process the conclusion was that this is a problem categorized as being NP-HARD by the computing community, and many people are doing research on this problem, so for now, it is only possible to develop a solution using brute force.


Juliana Rocha Fernandes
Faculdade de Inform√°tica - PUCRS
Nov. 27, 2016 
